import sys
import os
import uuid
import gc
import json
import psutil
import torch
import subprocess
import platform
import pdfplumber
import nltk
import numpy as np
from docx import Document
from bs4 import BeautifulSoup
import ebooklib
from ebooklib import epub
from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, 
    QLineEdit, QPushButton, QProgressBar, QTextEdit, QListWidget,
    QFileDialog, QFrame, QSpacerItem, QSizePolicy, QScrollArea,
    QListWidgetItem, QApplication
)
from PySide6.QtCore import Qt, QSize, QThread, Signal
from PySide6.QtGui import QIcon, QFont, QPalette, QColor

CUDA_AVAILABLE = torch.cuda.is_available()

from qwen_tts import Qwen3TTSModel

from pydub import AudioSegment

# Ensure NLTK tokenizer
try:
    nltk.download('punkt_tab', quiet=True)
except:
    nltk.download('punkt_tab', quiet=True)

# --- Config ---
MEMORY_THRESHOLD_MB = 500
CHUNKS_BEFORE_CLEANUP = 10
MAX_RETRIES = 2
BATCH_SIZE = 250
QWEN_MODEL_ID = "Qwen/Qwen3-TTS-12Hz-1.7B-CustomVoice"
SAMPLE_RATE = 12000

# --- Helpers ---
def get_memory_info():
    proc = psutil.Process()
    mem_info = proc.memory_info()
    virtual_mem = psutil.virtual_memory()
    return {
        'process_rss_mb': mem_info.rss / (1024*1024),
        'system_available_mb': virtual_mem.available / (1024*1024),
        'system_percent': virtual_mem.percent
    }

def clear_memory(verbose=None):
    if verbose:
        verbose("ðŸ§¹ Running memory cleanup...")
    collected = gc.collect()
    if torch.cuda.is_available():
        torch.cuda.synchronize()
        torch.cuda.empty_cache()
    if verbose:
        mem = get_memory_info()
        verbose(f"   Collected {collected} objects | RAM: {mem['process_rss_mb']:.1f}MB | Available: {mem['system_available_mb']:.1f}MB")

def should_reload_model(mem_info):
    return mem_info['system_available_mb'] < MEMORY_THRESHOLD_MB

def save_state(path, state):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(state, f, indent=2)

def load_state(path):
    if not os.path.exists(path):
        return None
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def extract_text_from_file(file_path):
    ext = os.path.splitext(file_path)[1].lower()
    if ext == '.txt':
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    elif ext == '.pdf':
        text = ''
        with pdfplumber.open(file_path) as pdf:
            for page in pdf.pages:
                text += page.extract_text() or ''
        return text
    elif ext == '.docx':
        doc = Document(file_path)
        return '\n'.join([p.text for p in doc.paragraphs])
    elif ext == '.epub':
        book = epub.read_epub(file_path)
        text = ''
        for item in book.get_items_of_type(ebooklib.ITEM_DOCUMENT):
            soup = BeautifulSoup(item.get_content(), 'html.parser')
            text += soup.get_text() + '\n'
        return text
    else:
        raise ValueError(f"Unsupported file format: {ext}")

def split_text_into_chunks(text, max_length=300):
    sentences = nltk.sent_tokenize(text)
    chunks, current_chunk = [], ""
    for s in sentences:
        if not s.strip():
            continue
        if len(current_chunk) + len(s) > max_length and current_chunk:
            chunks.append(current_chunk.strip())
            current_chunk = s
        else:
            current_chunk = f"{current_chunk} {s}" if current_chunk else s
    if current_chunk.strip():
        chunks.append(current_chunk.strip())
    return [c for c in chunks if len(c)>=10] or [text.strip()]

def adaptive_chunk_size():
    mem = psutil.virtual_memory().available / 1024**3
    if mem < 2: return 150
    elif mem < 4: return 250
    else: return 350

def concatenate_chunks(chunks_dir, output_file):
    combined = None
    for f in sorted(os.listdir(chunks_dir)):
        if not f.endswith(".mp3"):
            continue
        audio = AudioSegment.from_mp3(os.path.join(chunks_dir, f))
        combined = audio if combined is None else combined + audio
        del audio
        gc.collect()
    combined.export(output_file, format="mp3")

# --- Generation Thread ---
class GenerationThread(QThread):
    status_update = Signal(str)
    progress_update = Signal(int)
    chunk_progress = Signal(int)
    finished = Signal(bool, str, str)
    verbose_log = Signal(str)

    def __init__(self, text_file, voice_clip, voice_transcription, ref_duration, num_steps, batch_size=BATCH_SIZE, resume_dir=None):
        super().__init__()
        self.text_file = text_file
        self.voice_clip = voice_clip
        self.voice_transcription = voice_transcription
        self.ref_duration = ref_duration
        self.num_steps = num_steps
        self.batch_size = batch_size
        self.resume_dir = resume_dir
        self.model = None

    def log_verbose(self, msg):
        self.verbose_log.emit(msg)

    def log_memory_status(self, ctx=""):
        mem = get_memory_info()
        self.log_verbose(f"ðŸ’¾ Memory Status {ctx}: {mem['process_rss_mb']:.1f}MB RAM | {mem['system_available_mb']:.1f}MB avail")

    """def load_model(self):
        self.log_verbose("ðŸ”„ Loading LuxTTS model...")
        device = 'cuda' if CUDA_AVAILABLE else 'cpu'
        self.log_verbose(f"   Using device: {device}")
        self.lux_tts = LuxTTS('YatharthS/LuxTTS', device=device)
        self.log_verbose("âœ… Model loaded")"""
    
    def load_model(self):
        model = Qwen3TTSModel.from_pretrained(
        "Qwen/Qwen3-TTS-12Hz-1.7B-CustomVoice",
        device_map="cuda:0",
        dtype=torch.bfloat16,
        attn_implementation="flash_attention_2",
        )

    """def unload_model(self):
        if self.lux_tts is not None:
            self.log_verbose("ðŸ—‘ï¸ Unloading model...")
            del self.lux_tts
            self.lux_tts = None
            if torch.cuda.is_available():
                torch.cuda.synchronize()
                torch.cuda.empty_cache()
                torch.cuda.ipc_collect()
            clear_memory(self.log_verbose)
            self.log_memory_status("(after unload)")"""

    def run(self):
        try:
            self.log_verbose("="*60)
            self.log_verbose("ðŸš€ Starting audiobook generation")
            self.log_memory_status("(initial)")

            base_dir = "outputs"
            os.makedirs(base_dir, exist_ok=True)

            # Setup run folder
            if self.resume_dir:
                run_dir = self.resume_dir
                self.log_verbose(f"ðŸ” Resuming run {run_dir}")
            else:
                existing_runs = [d for d in os.listdir(base_dir) if d.startswith("output")]
                run_index = len(existing_runs)+1
                run_dir = os.path.join(base_dir, f"output{run_index}")
                os.makedirs(run_dir, exist_ok=True)
            chunks_dir = os.path.join(run_dir, "chunks")
            os.makedirs(chunks_dir, exist_ok=True)
            final_output_file = os.path.join(run_dir, "final.mp3")
            state_path = os.path.join(run_dir, "state.json")

            # Load or initialize state
            state = load_state(state_path) or {
                "run_id": str(uuid.uuid4())[:8],
                "book_file": self.text_file,
                "voice_clip": self.voice_clip,
                "voice_transcription": self.voice_transcription,
                "ref_duration": self.ref_duration,
                "num_steps": self.num_steps,
                "total_chunks": 0,
                "completed_chunks": [],
                "failed_chunks": [],
                "last_chunk": 0,
                "status": "running"
            }

            # Extract text
            self.status_update.emit("Extracting text...")
            book_text = extract_text_from_file(self.text_file)
            if not book_text.strip():
                self.finished.emit(False, "Book file is empty.", "")
                return

            # Load model
            self.load_model()

            # Split text into chunks and write each chunk to disk to avoid keeping huge lists in RAM
            chunks = split_text_into_chunks(book_text, max_length=adaptive_chunk_size())
            text_chunks_dir = os.path.join(run_dir, "text_chunks")
            os.makedirs(text_chunks_dir, exist_ok=True)
            # Only write chunk files if directory is empty (helps resume)
            if not any(f.endswith('.txt') for f in os.listdir(text_chunks_dir)):
                self.log_verbose(f"âœ‚ï¸ Writing {len(chunks)} text chunk files to disk...")
                for i, chunk in enumerate(chunks):
                    idx = i+1
                    with open(os.path.join(text_chunks_dir, f"chunk_{idx:06d}.txt"), "w", encoding="utf-8") as cf:
                        cf.write(chunk)
            # free the large in-memory text objects
            del chunks
            del book_text
            gc.collect()

            # Determine total chunks from files on disk
            chunk_files = sorted([f for f in os.listdir(text_chunks_dir) if f.endswith('.txt')])
            total_chunks = len(chunk_files)
            state["total_chunks"] = total_chunks
            save_state(state_path, state)
            self.status_update.emit(f"{total_chunks} chunks prepared on disk")

            # Process chunks in batches to limit VRAM usage
            for batch_start in range(0, total_chunks, self.batch_size):
                batch_files = chunk_files[batch_start:batch_start + self.batch_size]
                batch_index = (batch_start // self.batch_size) + 1
                self.log_verbose(f"ðŸ“¦ Starting batch {batch_index} ({len(batch_files)} chunks) with batch_size={self.batch_size}")

                for cfname in batch_files:
                    # chunk file names are chunk_000001.txt
                    chunk_num = int(cfname.split('_')[1].split('.')[0])
                    if chunk_num in state["completed_chunks"]:
                        self.log_verbose(f"â­ï¸ Skipping completed chunk {chunk_num}")
                        self.chunk_progress.emit(int(chunk_num/total_chunks*100))
                        continue

                    self.status_update.emit(f"Generating chunk {chunk_num}/{total_chunks}")
                    self.log_verbose(f"ðŸ“„ Loading chunk file: {cfname}")
                    with open(os.path.join(text_chunks_dir, cfname), 'r', encoding='utf-8') as cfh:
                        chunk = cfh.read()
                    self.log_verbose(f"ðŸ“ Chunk {chunk_num} ({len(chunk)} chars)")

                    # Memory cleanup
                    if chunk_num % CHUNKS_BEFORE_CLEANUP == 0:
                        clear_memory(self.log_verbose)
                    mem_info = get_memory_info()
                    if should_reload_model(mem_info):
                        self.log_verbose("ðŸ”„ Reloading model due to memory pressure...")
                        self.unload_model()
                        self.load_model()

                    # Generate with retry
                    for attempt in range(MAX_RETRIES + 1):
                        try:
                            wav = self.model.generate(
                                text=chunk,
                                voice=self.voice_clip,
                                language="en"
                            )
                            break
                        except RuntimeError as e:
                            self.log_verbose(f"ðŸ”¥ Error on chunk {chunk_num}: {e}")
                            if attempt < MAX_RETRIES:
                                gc.collect()
                                clear_memory(self.log_verbose)
                                self.unload_model()
                                self.load_model()
                            else:
                                raise

                    # Convert tensor to numpy
                    if isinstance(wav, torch.Tensor):
                        wav_np = wav.cpu().numpy().squeeze()
                    else:
                        wav_np = wav

                    if len(wav_np) < 100:
                        self.log_verbose(f"âš ï¸ Generated audio too short ({len(wav_np)} samples)")
                        state["failed_chunks"].append(chunk_num)
                        save_state(state_path, state)
                        continue

                    # Convert float32 [-1, 1] to int16
                    try:
                        if np.issubdtype(wav_np.dtype, np.floating):
                            wav_int16 = (np.clip(wav_np, -1.0, 1.0) * 32767).astype(np.int16)
                        else:
                            wav_int16 = wav_np.astype(np.int16) if wav_np.dtype != np.int16 else wav_np
                        raw_bytes = wav_int16.tobytes()
                    except Exception:
                        wav_int16 = (np.clip(wav_np, -1.0, 1.0) * 32767).astype(np.int16)
                        raw_bytes = wav_int16.tobytes()

                    seg = AudioSegment(raw_bytes, frame_rate=SAMPLE_RATE, sample_width=2, channels=1)
                    mp3_file = os.path.join(chunks_dir, f"chunk_{chunk_num:06d}.mp3")
                    # Export MP3 (for concatenation/streaming)
                    try:
                        seg.export(mp3_file, format="mp3", bitrate="192k")
                        self.log_verbose(f"ðŸ’¾ Saved MP3: {mp3_file}")
                    except Exception as e:
                        self.log_verbose(f"âš ï¸ Failed to save MP3 {mp3_file}: {e}")
                    del wav, wav_np, seg
                    gc.collect()

                    state["completed_chunks"].append(chunk_num)
                    state["last_chunk"] = chunk_num
                    save_state(state_path, state)
                    self.chunk_progress.emit(int(chunk_num/total_chunks*100))
                    self.progress_update.emit(int(chunk_num/total_chunks*100))

                # Finished batch: unload model and clear memory before next batch
                self.log_verbose(f"ðŸ§¹ Finished batch {batch_index} â€” unloading model and cleaning memory")
                self.unload_model()
                gc.collect()

            # Concatenate disk-backed
            self.status_update.emit("Concatenating audio (disk)...")
            concatenate_chunks(chunks_dir, final_output_file)
            state["status"] = "completed"
            save_state(state_path, state)
            self.unload_model()
            self.finished.emit(True, f"Audiobook ready: {final_output_file}", final_output_file)

        except Exception as e:
            state["status"] = "failed"
            save_state(state_path, state)
            import traceback
            self.log_verbose(traceback.format_exc())
            self.finished.emit(False, f"Error: {e}", "")

# ==================== MODERN COMPONENTS ====================

class ModernCard(QFrame):
    """A modern card container with subtle shadow effect"""
    def __init__(self, title=None, parent=None):
        super().__init__(parent)
        self.setObjectName("card")
        self.setStyleSheet("""
            QFrame#card {
                background-color: white;
                border-radius: 12px;
                border: 1px solid #e5e7eb;
            }
        """)
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)
        
        if title:
            title_label = QLabel(title)
            title_label.setStyleSheet("""
                font-size: 16px;
                font-weight: 600;
                color: #1f2937;
                margin-bottom: 5px;
            """)
            layout.addWidget(title_label)
            
            # Separator line
            separator = QFrame()
            separator.setFrameShape(QFrame.Shape.HLine)
            separator.setStyleSheet("background-color: #e5e7eb; max-height: 1px;")
            layout.addWidget(separator)


class ModernFileInput(QWidget):
    """Modern file input with icon and clean styling"""
    def __init__(self, label_text, placeholder, file_filter, is_save=False, parent=None):
        super().__init__(parent)
        self.file_filter = file_filter
        self.is_save = is_save
        
        layout = QVBoxLayout(self)
        layout.setSpacing(8)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # Label
        label = QLabel(label_text)
        label.setStyleSheet("""
            font-size: 13px;
            font-weight: 500;
            color: #374151;
        """)
        layout.addWidget(label)
        
        # Input row
        input_layout = QHBoxLayout()
        input_layout.setSpacing(8)
        
        self.entry = QLineEdit()
        self.entry.setPlaceholderText(placeholder)
        self.entry.setMinimumHeight(40)
        self.entry.setStyleSheet("""
            QLineEdit {
                padding: 0 12px;
                border: 1.5px solid #d1d5db;
                border-radius: 8px;
                font-size: 14px;
                background-color: #f9fafb;
                color: #1f2937;
            }
            QLineEdit:focus {
                border: 1.5px solid #3b82f6;
                background-color: white;
            }
            QLineEdit:hover {
                border: 1.5px solid #9ca3af;
            }
        """)
        
        browse_btn = QPushButton("Browse")
        browse_btn.setMinimumHeight(40)
        browse_btn.setMinimumWidth(90)
        browse_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        browse_btn.setStyleSheet("""
            QPushButton {
                background-color: #3b82f6;
                color: white;
                border: none;
                border-radius: 8px;
                font-size: 13px;
                font-weight: 500;
                padding: 0 16px;
            }
            QPushButton:hover {
                background-color: #2563eb;
            }
            QPushButton:pressed {
                background-color: #1d4ed8;
            }
        """)
        browse_btn.clicked.connect(self.browse)
        
        input_layout.addWidget(self.entry)
        input_layout.addWidget(browse_btn)
        layout.addLayout(input_layout)
    
    def browse(self):
        if self.is_save:
            file, _ = QFileDialog.getSaveFileName(self, "Save File", "", self.file_filter)
        else:
            file, _ = QFileDialog.getOpenFileName(self, "Select File", "", self.file_filter)
        if file:
            self.entry.setText(file)
    
    def text(self):
        return self.entry.text()


class ModernTextInput(QWidget):
    """Modern text input field"""
    def __init__(self, label_text, placeholder, parent=None):
        super().__init__(parent)
        
        layout = QVBoxLayout(self)
        layout.setSpacing(8)
        layout.setContentsMargins(0, 0, 0, 0)
        
        label = QLabel(label_text)
        label.setStyleSheet("""
            font-size: 13px;
            font-weight: 500;
            color: #374151;
        """)
        layout.addWidget(label)
        
        self.entry = QLineEdit()
        self.entry.setPlaceholderText(placeholder)
        self.entry.setMinimumHeight(40)
        self.entry.setStyleSheet("""
            QLineEdit {
                padding: 0 12px;
                border: 1.5px solid #d1d5db;
                border-radius: 8px;
                font-size: 14px;
                background-color: #f9fafb;
                color: #1f2937;
            }
            QLineEdit:focus {
                border: 1.5px solid #3b82f6;
                background-color: white;
            }
            QLineEdit:hover {
                border: 1.5px solid #9ca3af;
            }
        """)
        layout.addWidget(self.entry)
    
    def text(self):
        return self.entry.text()
    
    def setText(self, text):
        self.entry.setText(text)


class ModernNumberInput(QWidget):
    """Modern number input with label"""
    def __init__(self, label_text, default_value, parent=None):
        super().__init__(parent)
        
        layout = QHBoxLayout(self)
        layout.setSpacing(12)
        layout.setContentsMargins(0, 0, 0, 0)
        
        label = QLabel(label_text)
        label.setStyleSheet("""
            font-size: 13px;
            font-weight: 500;
            color: #374151;
            min-width: 60px;
        """)
        layout.addWidget(label)
        
        self.entry = QLineEdit(str(default_value))
        self.entry.setMaximumWidth(100)
        self.entry.setMinimumHeight(40)
        self.entry.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.entry.setStyleSheet("""
            QLineEdit {
                padding: 0 12px;
                border: 1.5px solid #d1d5db;
                border-radius: 8px;
                font-size: 14px;
                background-color: #f9fafb;
                color: #1f2937;
            }
            QLineEdit:focus {
                border: 1.5px solid #3b82f6;
                background-color: white;
            }
        """)
        layout.addWidget(self.entry)
        layout.addStretch()
    
    def text(self):
        return self.entry.text()


class ModernProgressBar(QWidget):
    """Modern progress bar with label"""
    def __init__(self, label_text, parent=None):
        super().__init__(parent)
        
        layout = QVBoxLayout(self)
        layout.setSpacing(8)
        layout.setContentsMargins(0, 0, 0, 0)
        
        self.label = QLabel(label_text)
        self.label.setStyleSheet("""
            font-size: 13px;
            font-weight: 500;
            color: #374151;
        """)
        layout.addWidget(self.label)
        
        self.progress = QProgressBar()
        self.progress.setMaximum(100)
        self.progress.setMinimumHeight(12)
        self.progress.setTextVisible(True)
        self.progress.setStyleSheet("""
            QProgressBar {
                border: none;
                border-radius: 6px;
                background-color: #e5e7eb;
                text-align: center;
                font-size: 11px;
                font-weight: 500;
                color: #1f2937;
            }
            QProgressBar::chunk {
                border-radius: 6px;
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #3b82f6, stop:1 #2563eb);
            }
        """)
        layout.addWidget(self.progress)
    
    def setValue(self, value):
        self.progress.setValue(value)
    
    def setLabelText(self, text):
        self.label.setText(text)


class ModernButton(QPushButton):
    """Modern button with variants"""
    def __init__(self, text, variant="primary", parent=None):
        super().__init__(text, parent)
        self.setMinimumHeight(44)
        self.setCursor(Qt.CursorShape.PointingHandCursor)
        
        if variant == "primary":
            self.setStyleSheet("""
                QPushButton {
                    background-color: #3b82f6;
                    color: white;
                    border: none;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: 600;
                    padding: 0 24px;
                }
                QPushButton:hover {
                    background-color: #2563eb;
                }
                QPushButton:pressed {
                    background-color: #1d4ed8;
                }
                QPushButton:disabled {
                    background-color: #9ca3af;
                }
            """)
        elif variant == "success":
            self.setStyleSheet("""
                QPushButton {
                    background-color: #10b981;
                    color: white;
                    border: none;
                    border-radius: 8px;
                    font-size: 13px;
                    font-weight: 500;
                    padding: 0 16px;
                }
                QPushButton:hover {
                    background-color: #059669;
                }
                QPushButton:pressed {
                    background-color: #047857;
                }
                QPushButton:disabled {
                    background-color: #9ca3af;
                }
            """)
        elif variant == "secondary":
            self.setStyleSheet("""
                QPushButton {
                    background-color: #f3f4f6;
                    color: #374151;
                    border: 1.5px solid #d1d5db;
                    border-radius: 8px;
                    font-size: 13px;
                    font-weight: 500;
                    padding: 0 16px;
                }
                QPushButton:hover {
                    background-color: #e5e7eb;
                }
                QPushButton:pressed {
                    background-color: #d1d5db;
                }
            """)


class RunHistoryItem(QWidget):
    """Modern run history list item"""
    resume_clicked = Signal(str)
    
    def __init__(self, run_dir, state, parent=None):
        super().__init__(parent)
        self.run_dir = run_dir
        
        layout = QHBoxLayout(self)
        layout.setContentsMargins(12, 10, 12, 10)
        layout.setSpacing(12)
        
        # Info section
        info_layout = QVBoxLayout()
        info_layout.setSpacing(4)
        
        name_label = QLabel(os.path.basename(run_dir))
        name_label.setStyleSheet("""
            font-size: 13px;
            font-weight: 600;
            color: #1f2937;
        """)
        info_layout.addWidget(name_label)
        
        status_text = f"{state['status'].title()} â€¢ {len(state['completed_chunks'])}/{state['total_chunks']} chunks"
        status_label = QLabel(status_text)
        status_label.setStyleSheet("""
            font-size: 12px;
            color: #6b7280;
        """)
        info_layout.addWidget(status_label)
        
        layout.addLayout(info_layout)
        layout.addStretch()
        
        # Resume button
        if state["status"] != "completed":
            resume_btn = ModernButton("â–¶ Resume", variant="success")
            resume_btn.setMaximumWidth(100)
            resume_btn.setMinimumHeight(36)
            resume_btn.clicked.connect(lambda: self.resume_clicked.emit(run_dir))
            layout.addWidget(resume_btn)


# ==================== MAIN WINDOW ====================

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Booklet - Audiobook Generator")
        self.resize(800, 950)
        
        # Set application-wide stylesheet
        self.setStyleSheet("""
            QMainWindow {
                background-color: #f9fafb;
            }
            QScrollArea {
                border: none;
                background-color: transparent;
            }
        """)
        
        # Create scroll area for main content
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        
        central_widget = QWidget()
        scroll.setWidget(central_widget)
        self.setCentralWidget(scroll)
        
        main_layout = QVBoxLayout(central_widget)
        main_layout.setSpacing(20)
        main_layout.setContentsMargins(30, 30, 30, 30)
        
        # ==================== HEADER ====================
        header = QLabel("ðŸŽ§ Audiobook Generator")
        header.setStyleSheet("""
            font-size: 28px;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 10px;
        """)
        main_layout.addWidget(header)
        
        subtitle = QLabel("Transform your books into professional audiobooks")
        subtitle.setStyleSheet("""
            font-size: 14px;
            color: #6b7280;
            margin-bottom: 10px;
        """)
        main_layout.addWidget(subtitle)
        
        # ==================== INPUT SECTION ====================
        input_card = ModernCard("Input Files")
        input_layout = input_card.layout()
        
        self.text_input = ModernFileInput(
            "Book File",
            "Select TXT, PDF, DOCX, or EPUB file",
            "Book Files (*.txt *.pdf *.docx *.epub)"
        )
        input_layout.addWidget(self.text_input)
        
        self.voice_input = ModernFileInput(
            "Voice Sample",
            "Select WAV or MP3 audio file",
            "Audio Files (*.wav *.mp3)"
        )
        input_layout.addWidget(self.voice_input)
        
        self.trans_input = ModernTextInput(
            "Voice Transcription",
            "Enter the transcription of your voice sample"
        )
        input_layout.addWidget(self.trans_input)
        
        main_layout.addWidget(input_card)
        
        # ==================== SETTINGS SECTION ====================
        settings_card = ModernCard("Generation Settings")
        settings_layout = settings_card.layout()
        
        params_row = QHBoxLayout()
        params_row.setSpacing(20)
        
        self.ref_entry = ModernNumberInput("Reference:", 5)
        params_row.addWidget(self.ref_entry)
        
        self.steps_entry = ModernNumberInput("Steps:", 4)
        params_row.addWidget(self.steps_entry)

        self.batch_entry = ModernNumberInput("Batch Size:", BATCH_SIZE)
        params_row.addWidget(self.batch_entry)
        
        settings_layout.addLayout(params_row)
        
        main_layout.addWidget(settings_card)
        
        # ==================== ACTION BUTTON ====================
        self.generate_btn = ModernButton("ðŸš€ Generate Audiobook", variant="primary")
        self.generate_btn.setMinimumHeight(50)
        self.generate_btn.clicked.connect(self.start_generation)
        main_layout.addWidget(self.generate_btn)
        
        # ==================== STATUS SECTION ====================
        status_card = ModernCard("Generation Status")
        status_layout = status_card.layout()
        
        self.status_label = QLabel("Ready to generate")
        self.status_label.setStyleSheet("""
            font-size: 14px;
            color: #374151;
            padding: 8px 0;
        """)
        status_layout.addWidget(self.status_label)
        
        self.progress_bar = ModernProgressBar("Overall Progress")
        status_layout.addWidget(self.progress_bar)
        
        self.chunk_progress = ModernProgressBar("Current Chunk")
        status_layout.addWidget(self.chunk_progress)
        
        main_layout.addWidget(status_card)
        
        # ==================== LOG SECTION ====================
        log_card = ModernCard("Generation Log")
        log_layout = log_card.layout()
        
        self.verbose_log = QTextEdit()
        self.verbose_log.setReadOnly(True)
        self.verbose_log.setMinimumHeight(200)
        self.verbose_log.setStyleSheet("""
            QTextEdit {
                background-color: #f9fafb;
                border: 1px solid #e5e7eb;
                border-radius: 8px;
                padding: 12px;
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 12px;
                color: #374151;
                line-height: 1.5;
            }
        """)
        log_layout.addWidget(self.verbose_log)
        
        main_layout.addWidget(log_card)
        
        # ==================== HISTORY SECTION ====================
        history_card = ModernCard("Generation History")
        history_layout = history_card.layout()
        
        self.history_list = QListWidget()
        self.history_list.setMinimumHeight(200)
        self.history_list.setSpacing(8)
        self.history_list.setStyleSheet("""
            QListWidget {
                background-color: #f9fafb;
                border: 1px solid #e5e7eb;
                border-radius: 8px;
                padding: 8px;
            }
            QListWidget::item {
                background-color: white;
                border: 1px solid #e5e7eb;
                border-radius: 8px;
                padding: 0;
                margin: 2px 0;
            }
            QListWidget::item:selected {
                background-color: #eff6ff;
                border: 1px solid #3b82f6;
            }
            QListWidget::item:hover {
                background-color: #f3f4f6;
            }
        """)
        history_layout.addWidget(self.history_list)
        
        main_layout.addWidget(history_card)
        
        # Add stretch at the end
        main_layout.addStretch()
        
        # Load history
        self.load_run_history()
    
    def start_generation(self):
        """Handle generation start - placeholder for actual implementation"""
        self.status_label.setText("Starting generation...")
        self.verbose_log.append("[INFO] Generation started")
        # Add your generation logic here
    
    def load_run_history(self):
        """Load previous runs - placeholder for actual implementation"""
        # Example data - replace with actual data loading
        example_runs = [
            {"dir": "run_2024_01_15", "status": "completed", "completed_chunks": 100, "total_chunks": 100},
            {"dir": "run_2024_01_14", "status": "paused", "completed_chunks": 45, "total_chunks": 100},
            {"dir": "run_2024_01_13", "status": "running", "completed_chunks": 23, "total_chunks": 80},
        ]
        
        for run in example_runs:
            item_widget = RunHistoryItem(run["dir"], run)
            item_widget.resume_clicked.connect(self.resume_run)
            
            list_item = QListWidgetItem(self.history_list)
            list_item.setSizeHint(item_widget.sizeHint())
            self.history_list.setItemWidget(list_item, item_widget)
    
    def resume_run(self, run_dir):
        """Resume a previous run"""
        self.status_label.setText(f"Resuming {run_dir}...")
        self.verbose_log.append(f"[INFO] Resuming run: {run_dir}")
        # Add your resume logic here


    def start_generation(self):
        text_file = self.text_input.text()
        voice_clip = self.voice_input.text()
        transcription = self.trans_input.text()
        try:
            ref = int(self.ref_entry.text())
            steps = int(self.steps_entry.text())
            batch_size = int(self.batch_entry.text())
        except:
            return
        if not all([text_file, voice_clip, transcription]): return
        self.verbose_log.clear()
        self.generate_btn.setEnabled(False)
        self.thread = GenerationThread(text_file, voice_clip, transcription, ref, steps, batch_size=batch_size)
        self.thread.status_update.connect(lambda t: self.status_label.setText(t))
        self.thread.progress_update.connect(lambda v: self.progress_bar.setValue(v))
        self.thread.chunk_progress.connect(lambda v: self.chunk_progress.setValue(v))
        self.thread.verbose_log.connect(lambda t: self.verbose_log.append(t))
        self.thread.finished.connect(self.gen_finished)
        self.thread.start()

    def gen_finished(self, success, msg, output):
        self.generate_btn.setEnabled(True)
        self.status_label.setText(msg)
        self.load_run_history()
        if success and output:
            try:
                if platform.system() == "Windows": os.startfile(os.path.dirname(output))
                elif platform.system() == "Darwin": subprocess.run(["open", os.path.dirname(output)])
                else: subprocess.run(["xdg-open", os.path.dirname(output)])
            except: pass

    def load_run_history(self):
        self.history_list.clear()
        base = "outputs"
        if not os.path.exists(base): return
        for d in sorted(os.listdir(base)):
            run_dir = os.path.join(base, d)
            state_path = os.path.join(run_dir,"state.json")
            if not os.path.exists(state_path): continue
            state = load_state(state_path)
            item = QListWidgetItem()
            widget = RunHistoryItem(run_dir, state)
            widget.resume_clicked.connect(self.resume_run)
            item.setSizeHint(widget.sizeHint())
            self.history_list.addItem(item)
            self.history_list.setItemWidget(item, widget)

    def resume_run(self, run_dir):
        state = load_state(os.path.join(run_dir,"state.json"))
        self.thread = GenerationThread(state["book_file"], state["voice_clip"], state["voice_transcription"], state["ref_duration"], state["num_steps"], resume_dir=run_dir)
        self.thread.status_update.connect(lambda t: self.status_label.setText(t))
        self.thread.progress_update.connect(lambda v: self.progress_bar.setValue(v))
        self.thread.chunk_progress.connect(lambda v: self.chunk_progress.setValue(v))
        self.thread.verbose_log.connect(lambda t: self.verbose_log.append(t))
        self.thread.finished.connect(self.gen_finished)
        self.thread.start()

# --- Run ---
if __name__=="__main__":
    app = QApplication(sys.argv)
    font = QFont("Segoe UI",10)
    app.setFont(font)
    win = MainWindow()
    win.show()
    sys.exit(app.exec())